---
import BaseLayout from "@layouts/BaseLayout.astro"
import Article from "@components/Article.astro"
import Dropdown from "@components/Dropdown.astro"
import OutputBox from "@/components/OutputBox.astro"
---

<BaseLayout title="RNN Language Model">
  <Article>
    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
      <label for="selection" style="font-weight: bold;">Book:</label>
      <Dropdown id="selection" style="padding: 0.25rem 0.5rem;"></Dropdown>
      <button id="generate" disabled style="padding: 0.4rem 0.8rem; flex-basis: 100%; max-width: max-content; ">Loading..</button>
    </div>
	<div id="output" style="margin-top: 1rem; font-family: ui-monospace, Menlo, monospace;"></div>

	<div style="border-top:  0.2rem solid #000; margin-top: 3rem; ">
		<p>This is a character level LSTM Recurrent Neural Network trained on the Bible as a text corpus, written in pytorch and served clientside within the web browser via ONNX web runtime.</p>

        <p>The original text starts with the book name, followed by a tab character, and ending with the newline character, which proved to be very useful as it allowed clear delineations between the start of each verse, the book and verse strings, and the end of the verse.</p>

        <p>the model uses an embedding layer to convert the vocabulary (characters or tokens) into embedding tensors of length defined by hidden dimension, followed by a dropout layer, several lstm layers, another dropout layer, and lastly a fully connected layer, outputting logits and the updated hidden state. softmax was done as a seperate step during the model development phase to allow for temperature experimentation, but for model export, the model was placed in a wrapper which included the softmax layer (with temperature = 1 baked in) and unpacked the hidden state pair into a (hidden, cell) state tuple to simplify feeding onnx-web runtime tensors through the model.</p>

		<p>initial models used one-hot encoding, and were later switched to token embeddings which substantially improved the results. After training for 20ish epochs, the results are decent [insert an example of output], but obviously had room for improvement. in the course of training i used the validation set to tweak my training parameters to make sure i wasn't overfitting. on some of the earlier models you can see the validation loss plateau well while the training loss continues to decrease, indicating overfitting.</p>

		<p>text generation is handled recurrently by feeding the hidden state and previously generated token back into the model. the hidden state consists of two tensors, a hidden and a cell state, with dimensions [# of lstm layers, batch size, hidden dimension], both initialized with zero vectors. during training, batch size > 1 allows for multiple sequences to be processed in parallel [not totally sure about correctness of this fact] but during generation batch size was set to 1 to force token by token generation. during generation the hidden state is primed by running a predetermined sequence of tokens through the model, updating the hidden state in-place and discarding the generated token, replacing it with the next token in the predetermined sequence, until the priming sequence is exhausted. the final generated token at the end of the priming process is then used as the first true output token, and the model is then allowed to run recurrently, using its own outputs to generate new ones</p>

		<p>several priming sequences were experimented with, such as the tab character (which in our corpus starts the verse string), the book name in full, as well as the <code>&lt;</code> character, which is the character leading the book title ( eg. <code>&lt;Genesis&gt;</Genesis></code>)</p>

		<p>i also experimented with leaving the book title in vs. simply starting each verse with the tab characters; ultimately the model performed quite well with the book titles included, even being able to select and generate book names when primed with only <code>&lt;</code>, so i kept them.</p>

		<p>for training, hidden states are reset at the end of each batch to ensure that we're not carrying data over between verses. for the "full text string" versions of the model, which chunked up the entire text into fixed length sequence, i did experiment with resetting the hidden state each epoch, but this did not make a huge difference, presumably because the sequences weren't starting or terminating on verses, but were all arbitrary sections of verses.</p>

		<p>the biggest jump in performance came after splitting sequences along verses, and allowing for arbitrary length training sequences (ensuring all verses are one continous sequence, and never split) by taking a batch of sequences, and right padding with the `<>` pad token, and resetting the hidden state each batch. this method of batching allowed i believe for true full sequence learning, with hidden states initialized at 0 and resetting at the end of each sequence, as opposed to previously, where the model was merely seeing snippets of sequences out of context (which actually performed surprisingly well for what it was)</p>

		<p>porting to the onnx web runtime was a fairly straightfoward, though fairly involved process. becuase onnx only saves the network graph [i'm not sure the word for this], the entirety of the text generation code needed to be ported over to javascript. this included carrying over the model vocabulary to create index to token and token to index lookup tables, as well as the model dimensions needed to initialize the hidden states (# of lstm layers and hidden dimension). for memory optimization i compressed the vocabulary down into a single string of characters in the same order as their respective indices, and seperately stored the special <code>&lt;&gt;</code>, <code>\t</code>>, and <code>n</code>> tokens; these two lists allowed me to rebuild the idx2token and token2idx tables within javascript client-side. to simplify runtime, the hidedn state tuple was expanded to the hidden and cell state tensors rather than paired, and the softmax calculation was packaged with the model with a temperature setting of 1, so that the exported model accepts [token index, hidden state, cell state] as inputs and outputs [softmaxed probabilities across the vocabulary of tokens, hidden state, cell state] directly. i wrote a basic multinomial sampling function to grab the token index from the probability vector outputted by the model, and, just as in the pytorch script, converted this back into a character via the idx2token lookup table, </p>

		<p>future developments will be gpu support (the current model is trained entirely on cpu, as i did not have a gpu at the time, but having recently purchased one, i'm eager to try it out) as well as word-level or byte-pair tokenization. i did briefly experiment with word-level tokenization, but because of the increase in vocabulary size as a result of cataloguing individual words rather than unique characters, it created substantially larger models than the character level ones (&gt;100mb) and were larger than github would allow hosting, so this idea was abandoned as it would be too large to allow for in-browser inference on a hosted github pages site. however, it seems that because converting into onnx strips out the optimizer, the onnx models are about half the size of the pytorch models, so this has resurfaced as an avenue worth exploring.</p>

		<p>all in all this was an incredibly informative experience during which i got to touch all aspects of ml model deployment, from data cleaning and preparation, model architecture implementation, training finetuning, model export, and porting generation code for client-side inference.</p>
		
		<p>You can find the PyTorch code for this model, as well as some of my other language modelling projects, in this <a href="https://github.com/ruitaiS/language_models">[GitHub Repository]</a>.</p>
	</div>

    <script>
      import { initialize_ort } from "@scripts/ort_handler";
      const { ort, session } = await initialize_ort();
	  type Tensor = import('onnxruntime-web').Tensor;
	  
	  const selection = document.getElementById('selection')! as HTMLSelectElement;
      const button = document.getElementById('generate')! as HTMLButtonElement;
      const output = document.getElementById('output')! as HTMLElement;
	  
      const model_assets = await fetch('/bible-rnn/model_assets.json').then(r => r.json());
      const idx2token = [...model_assets.specials, ...model_assets.chars];
      const token2idx: Record<string, number> = {};
      for (let i = 0; i < idx2token.length; i++) {
        token2idx[idx2token[i]] = i;
      }
      button.disabled = false;
      button.textContent="Generate";

	  function multinomial(probs: ArrayLike<number>){
		  let acc = 0;
		  const r = Math.random();
		  for (let i = 0; i < probs.length; i++){
			  acc += probs[i];
			  if (r < acc){
				  return i;
			  };
		  };
		  return token2idx['\n']; // End token as fallback
	  };

	  async function prime_hidden(priming_indices: number[]){
		  const h = new ort.Tensor(
			  'float32',
			  new Float32Array(model_assets.lstm_layers * model_assets.hidden_dim),
			  [model_assets.lstm_layers, 1, model_assets.hidden_dim]);
		  const c = new ort.Tensor(
			  'float32',
			  new Float32Array(model_assets.lstm_layers * model_assets.hidden_dim),
			  [model_assets.lstm_layers, 1, model_assets.hidden_dim]);

		  const hidden = { "h": h, "c": c };
		  let token_idx = token2idx['\n']; // Fallback
		  for (let i = 0; i < priming_indices.length; i++){
			  // Prime the hidden state
			  // Final value of token_idx is our first response token
			  token_idx = await next_token(priming_indices[i], hidden);
		  }
		  return { token_idx, hidden }
	  };

	  const buf = new BigInt64Array(1);
	  async function next_token(token_idx: number, hidden: Record<string, Tensor>){
		  buf[0] = BigInt(token_idx);
		  const output = await session.run({
			  "input_idx": new ort.Tensor('int64', buf, [1,1]),
			  "input_h": hidden.h,
			  "input_c": hidden.c
		  });
		  hidden.h = output['h'];
		  hidden.c = output['c'];
		  const probs = output['probs'].data as Float32Array;
		  return multinomial(probs);
	  };

      async function sample(prime: string) {
		  let response = "";
		  const priming_indices = Array.from(prime).map(char => token2idx[char]);
		  let { token_idx, hidden } = await prime_hidden(priming_indices);
		  while (idx2token[token_idx] != '\n' && response.length < 500){
			  response = response + idx2token[token_idx];
			  output.textContent = `${response}`;
			  await new Promise(requestAnimationFrame); // TODO: worker + rAF; this is too slow
			  token_idx = await next_token(token_idx, hidden);
		  };		  
	  };
      button.addEventListener('click', () => {
        sample(selection.value);
      });
    </script>
  </Article>
</BaseLayout>
